<?xml version="1.0" ?>
<testsuites>
    <testsuite tests="22" failures="22" name="luke19/familypostman@sha256:1eeb4fd8b3f53be09f46ee4fc1d4a47e9ee450a2681b4d58e82283b73e5739f7 (alpine 3.11.11)" errors="0" skipped="0" time="">
        <properties>
            <property name="type" value="alpine"></property>
        </properties>
        <testcase classname="busybox-1.31.1-r10" name="[HIGH] CVE-2021-42378" time="">
            <failure message="busybox: use-after-free in awk applet leads to denial of service and possibly code execution when processing a crafted awk pattern in the getvar_i()" type="description">A use-after-free in Busybox&#39;s awk applet leads to denial of service and possibly code execution when processing a crafted awk pattern in the getvar_i function</failure>
        </testcase>
        <testcase classname="busybox-1.31.1-r10" name="[HIGH] CVE-2021-42379" time="">
            <failure message="busybox: use-after-free in awk applet leads to denial of service and possibly code execution when processing a crafted awk pattern in the next_input_file()" type="description">A use-after-free in Busybox&#39;s awk applet leads to denial of service and possibly code execution when processing a crafted awk pattern in the next_input_file function</failure>
        </testcase>
        <testcase classname="busybox-1.31.1-r10" name="[HIGH] CVE-2021-42380" time="">
            <failure message="busybox: use-after-free in awk applet leads to denial of service and possibly code execution when processing a crafted awk pattern in the clrvar()" type="description">A use-after-free in Busybox&#39;s awk applet leads to denial of service and possibly code execution when processing a crafted awk pattern in the clrvar function</failure>
        </testcase>
        <testcase classname="busybox-1.31.1-r10" name="[HIGH] CVE-2021-42381" time="">
            <failure message="busybox: use-after-free in awk applet leads to denial of service and possibly code execution when processing a crafted awk pattern in the hash_init()" type="description">A use-after-free in Busybox&#39;s awk applet leads to denial of service and possibly code execution when processing a crafted awk pattern in the hash_init function</failure>
        </testcase>
        <testcase classname="busybox-1.31.1-r10" name="[HIGH] CVE-2021-42382" time="">
            <failure message="busybox: use-after-free in awk applet leads to denial of service and possibly code execution when processing a crafted awk pattern in the getvar_s()" type="description">A use-after-free in Busybox&#39;s awk applet leads to denial of service and possibly code execution when processing a crafted awk pattern in the getvar_s function</failure>
        </testcase>
        <testcase classname="busybox-1.31.1-r10" name="[HIGH] CVE-2021-42383" time="">
            <failure message="busybox: use-after-free in awk applet leads to denial of service and possibly code execution when processing a crafted awk pattern in the evaluate()" type="description">A use-after-free in Busybox&#39;s awk applet leads to denial of service and possibly code execution when processing a crafted awk pattern in the evaluate function</failure>
        </testcase>
        <testcase classname="busybox-1.31.1-r10" name="[HIGH] CVE-2021-42384" time="">
            <failure message="busybox: use-after-free in awk applet leads to denial of service and possibly code execution when processing a crafted awk pattern in the handle_special()" type="description">A use-after-free in Busybox&#39;s awk applet leads to denial of service and possibly code execution when processing a crafted awk pattern in the handle_special function</failure>
        </testcase>
        <testcase classname="busybox-1.31.1-r10" name="[HIGH] CVE-2021-42385" time="">
            <failure message="busybox: use-after-free in awk applet leads to denial of service and possibly code execution when processing a crafted awk pattern in the evaluate()" type="description">A use-after-free in Busybox&#39;s awk applet leads to denial of service and possibly code execution when processing a crafted awk pattern in the evaluate function</failure>
        </testcase>
        <testcase classname="busybox-1.31.1-r10" name="[HIGH] CVE-2021-42386" time="">
            <failure message="busybox: use-after-free in awk applet leads to denial of service and possibly code execution when processing a crafted awk pattern in the nvalloc()" type="description">A use-after-free in Busybox&#39;s awk applet leads to denial of service and possibly code execution when processing a crafted awk pattern in the nvalloc function</failure>
        </testcase>
        <testcase classname="busybox-1.31.1-r10" name="[MEDIUM] CVE-2021-42374" time="">
            <failure message="busybox: out-of-bounds read in unlzma applet leads to information leak and denial of service when crafted LZMA-compressed input is decompressed" type="description">An out-of-bounds heap read in Busybox&#39;s unlzma applet leads to information leak and denial of service when crafted LZMA-compressed input is decompressed. This can be triggered by any applet/format that</failure>
        </testcase>
        <testcase classname="libcrypto1.1-1.1.1k-r0" name="[HIGH] CVE-2021-3712" time="">
            <failure message="openssl: Read buffer overruns processing ASN.1 strings" type="description">ASN.1 strings are represented internally within OpenSSL as an ASN1_STRING structure which contains a buffer holding the string data and a field holding the buffer length. This contrasts with normal C strings which are repesented as a buffer for the string data which is terminated with a NUL (0) byte. Although not a strict requirement, ASN.1 strings that are parsed using OpenSSL&#39;s own &#34;d2i&#34; functions (and other similar parsing functions) as well as any string whose value has been set with the ASN1_STRING_set() function will additionally NUL terminate the byte array in the ASN1_STRING structure. However, it is possible for applications to directly construct valid ASN1_STRING structures which do not NUL terminate the byte array by directly setting the &#34;data&#34; and &#34;length&#34; fields in the ASN1_STRING array. This can also happen by using the ASN1_STRING_set0() function. Numerous OpenSSL functions that print ASN.1 data have been found to assume that the ASN1_STRING byte array will be NUL terminated, even though this is not guaranteed for strings that have been directly constructed. Where an application requests an ASN.1 structure to be printed, and where that ASN.1 structure contains ASN1_STRINGs that have been directly constructed by the application without NUL terminating the &#34;data&#34; field, then a read buffer overrun can occur. The same thing can also occur during name constraints processing of certificates (for example if a certificate has been directly constructed by the application instead of loading it via the OpenSSL parsing functions, and the certificate contains non NUL terminated ASN1_STRING structures). It can also occur in the X509_get1_email(), X509_REQ_get1_email() and X509_get1_ocsp() functions. If a malicious actor can cause an application to directly construct an ASN1_STRING and then process it through one of the affected OpenSSL functions then this issue could be hit. This might result in a crash (causing a Denial of Service attack). It could also result in the disclosure of private memory contents (such as private keys, or sensitive plaintext). Fixed in OpenSSL 1.1.1l (Affected 1.1.1-1.1.1k). Fixed in OpenSSL 1.0.2za (Affected 1.0.2-1.0.2y).</failure>
        </testcase>
        <testcase classname="libssl1.1-1.1.1k-r0" name="[HIGH] CVE-2021-3712" time="">
            <failure message="openssl: Read buffer overruns processing ASN.1 strings" type="description">ASN.1 strings are represented internally within OpenSSL as an ASN1_STRING structure which contains a buffer holding the string data and a field holding the buffer length. This contrasts with normal C strings which are repesented as a buffer for the string data which is terminated with a NUL (0) byte. Although not a strict requirement, ASN.1 strings that are parsed using OpenSSL&#39;s own &#34;d2i&#34; functions (and other similar parsing functions) as well as any string whose value has been set with the ASN1_STRING_set() function will additionally NUL terminate the byte array in the ASN1_STRING structure. However, it is possible for applications to directly construct valid ASN1_STRING structures which do not NUL terminate the byte array by directly setting the &#34;data&#34; and &#34;length&#34; fields in the ASN1_STRING array. This can also happen by using the ASN1_STRING_set0() function. Numerous OpenSSL functions that print ASN.1 data have been found to assume that the ASN1_STRING byte array will be NUL terminated, even though this is not guaranteed for strings that have been directly constructed. Where an application requests an ASN.1 structure to be printed, and where that ASN.1 structure contains ASN1_STRINGs that have been directly constructed by the application without NUL terminating the &#34;data&#34; field, then a read buffer overrun can occur. The same thing can also occur during name constraints processing of certificates (for example if a certificate has been directly constructed by the application instead of loading it via the OpenSSL parsing functions, and the certificate contains non NUL terminated ASN1_STRING structures). It can also occur in the X509_get1_email(), X509_REQ_get1_email() and X509_get1_ocsp() functions. If a malicious actor can cause an application to directly construct an ASN1_STRING and then process it through one of the affected OpenSSL functions then this issue could be hit. This might result in a crash (causing a Denial of Service attack). It could also result in the disclosure of private memory contents (such as private keys, or sensitive plaintext). Fixed in OpenSSL 1.1.1l (Affected 1.1.1-1.1.1k). Fixed in OpenSSL 1.0.2za (Affected 1.0.2-1.0.2y).</failure>
        </testcase>
        <testcase classname="ssl_client-1.31.1-r10" name="[HIGH] CVE-2021-42378" time="">
            <failure message="busybox: use-after-free in awk applet leads to denial of service and possibly code execution when processing a crafted awk pattern in the getvar_i()" type="description">A use-after-free in Busybox&#39;s awk applet leads to denial of service and possibly code execution when processing a crafted awk pattern in the getvar_i function</failure>
        </testcase>
        <testcase classname="ssl_client-1.31.1-r10" name="[HIGH] CVE-2021-42379" time="">
            <failure message="busybox: use-after-free in awk applet leads to denial of service and possibly code execution when processing a crafted awk pattern in the next_input_file()" type="description">A use-after-free in Busybox&#39;s awk applet leads to denial of service and possibly code execution when processing a crafted awk pattern in the next_input_file function</failure>
        </testcase>
        <testcase classname="ssl_client-1.31.1-r10" name="[HIGH] CVE-2021-42380" time="">
            <failure message="busybox: use-after-free in awk applet leads to denial of service and possibly code execution when processing a crafted awk pattern in the clrvar()" type="description">A use-after-free in Busybox&#39;s awk applet leads to denial of service and possibly code execution when processing a crafted awk pattern in the clrvar function</failure>
        </testcase>
        <testcase classname="ssl_client-1.31.1-r10" name="[HIGH] CVE-2021-42381" time="">
            <failure message="busybox: use-after-free in awk applet leads to denial of service and possibly code execution when processing a crafted awk pattern in the hash_init()" type="description">A use-after-free in Busybox&#39;s awk applet leads to denial of service and possibly code execution when processing a crafted awk pattern in the hash_init function</failure>
        </testcase>
        <testcase classname="ssl_client-1.31.1-r10" name="[HIGH] CVE-2021-42382" time="">
            <failure message="busybox: use-after-free in awk applet leads to denial of service and possibly code execution when processing a crafted awk pattern in the getvar_s()" type="description">A use-after-free in Busybox&#39;s awk applet leads to denial of service and possibly code execution when processing a crafted awk pattern in the getvar_s function</failure>
        </testcase>
        <testcase classname="ssl_client-1.31.1-r10" name="[HIGH] CVE-2021-42383" time="">
            <failure message="busybox: use-after-free in awk applet leads to denial of service and possibly code execution when processing a crafted awk pattern in the evaluate()" type="description">A use-after-free in Busybox&#39;s awk applet leads to denial of service and possibly code execution when processing a crafted awk pattern in the evaluate function</failure>
        </testcase>
        <testcase classname="ssl_client-1.31.1-r10" name="[HIGH] CVE-2021-42384" time="">
            <failure message="busybox: use-after-free in awk applet leads to denial of service and possibly code execution when processing a crafted awk pattern in the handle_special()" type="description">A use-after-free in Busybox&#39;s awk applet leads to denial of service and possibly code execution when processing a crafted awk pattern in the handle_special function</failure>
        </testcase>
        <testcase classname="ssl_client-1.31.1-r10" name="[HIGH] CVE-2021-42385" time="">
            <failure message="busybox: use-after-free in awk applet leads to denial of service and possibly code execution when processing a crafted awk pattern in the evaluate()" type="description">A use-after-free in Busybox&#39;s awk applet leads to denial of service and possibly code execution when processing a crafted awk pattern in the evaluate function</failure>
        </testcase>
        <testcase classname="ssl_client-1.31.1-r10" name="[HIGH] CVE-2021-42386" time="">
            <failure message="busybox: use-after-free in awk applet leads to denial of service and possibly code execution when processing a crafted awk pattern in the nvalloc()" type="description">A use-after-free in Busybox&#39;s awk applet leads to denial of service and possibly code execution when processing a crafted awk pattern in the nvalloc function</failure>
        </testcase>
        <testcase classname="ssl_client-1.31.1-r10" name="[MEDIUM] CVE-2021-42374" time="">
            <failure message="busybox: out-of-bounds read in unlzma applet leads to information leak and denial of service when crafted LZMA-compressed input is decompressed" type="description">An out-of-bounds heap read in Busybox&#39;s unlzma applet leads to information leak and denial of service when crafted LZMA-compressed input is decompressed. This can be triggered by any applet/format that</failure>
        </testcase>
    </testsuite>
    <testsuite tests="11" failures="11" name="Node.js" errors="0" skipped="0" time="">
        <properties>
            <property name="type" value="node-pkg"></property>
        </properties>
        <testcase classname="ansi-regex-3.0.0" name="[HIGH] CVE-2021-3807" time="">
            <failure message="nodejs-ansi-regex: Regular expression denial of service (ReDoS) matching ANSI escape codes" type="description">ansi-regex is vulnerable to Inefficient Regular Expression Complexity</failure>
        </testcase>
        <testcase classname="ansi-regex-4.1.0" name="[HIGH] CVE-2021-3807" time="">
            <failure message="nodejs-ansi-regex: Regular expression denial of service (ReDoS) matching ANSI escape codes" type="description">ansi-regex is vulnerable to Inefficient Regular Expression Complexity</failure>
        </testcase>
        <testcase classname="ansi-regex-5.0.0" name="[HIGH] CVE-2021-3807" time="">
            <failure message="nodejs-ansi-regex: Regular expression denial of service (ReDoS) matching ANSI escape codes" type="description">ansi-regex is vulnerable to Inefficient Regular Expression Complexity</failure>
        </testcase>
        <testcase classname="hosted-git-info-2.8.8" name="[MEDIUM] CVE-2021-23362" time="">
            <failure message="nodejs-hosted-git-info: Regular Expression denial of service via shortcutMatch in fromUrl()" type="description">The package hosted-git-info before 3.0.8 are vulnerable to Regular Expression Denial of Service (ReDoS) via regular expression shortcutMatch in the fromUrl function in index.js. The affected regular expression exhibits polynomial worst-case time complexity.</failure>
        </testcase>
        <testcase classname="path-parse-1.0.6" name="[HIGH] CVE-2021-23343" time="">
            <failure message="nodejs-path-parse: ReDoS via splitDeviceRe, splitTailRe and splitPathRe" type="description">All versions of package path-parse are vulnerable to Regular Expression Denial of Service (ReDoS) via splitDeviceRe, splitTailRe, and splitPathRe regular expressions. ReDoS exhibits polynomial worst-case time complexity.</failure>
        </testcase>
        <testcase classname="ssri-6.0.1" name="[HIGH] CVE-2021-27290" time="">
            <failure message="nodejs-ssri: Regular expression DoS (ReDoS) when parsing malicious SRI in strict mode" type="description">ssri 5.2.2-8.0.0, fixed in 8.0.1, processes SRIs using a regular expression which is vulnerable to a denial of service. Malicious SRIs could take an extremely long time to process, leading to denial of service. This issue only affects consumers using the strict option.</failure>
        </testcase>
        <testcase classname="tar-4.4.13" name="[HIGH] CVE-2021-32803" time="">
            <failure message="nodejs-tar: Insufficient symlink protection allowing arbitrary file creation and overwrite" type="description">The npm package &#34;tar&#34; (aka node-tar) before versions 6.1.2, 5.0.7, 4.4.15, and 3.2.3 has an arbitrary File Creation/Overwrite vulnerability via insufficient symlink protection. `node-tar` aims to guarantee that any file whose location would be modified by a symbolic link is not extracted. This is, in part, achieved by ensuring that extracted directories are not symlinks. Additionally, in order to prevent unnecessary `stat` calls to determine whether a given path is a directory, paths are cached when directories are created. This logic was insufficient when extracting tar files that contained both a directory and a symlink with the same name as the directory. This order of operations resulted in the directory being created and added to the `node-tar` directory cache. When a directory is present in the directory cache, subsequent calls to mkdir for that directory are skipped. However, this is also where `node-tar` checks for symlinks occur. By first creating a directory, and then replacing that directory with a symlink, it was thus possible to bypass `node-tar` symlink checks on directories, essentially allowing an untrusted tar file to symlink into an arbitrary location and subsequently extracting arbitrary files into that location, thus allowing arbitrary file creation and overwrite. This issue was addressed in releases 3.2.3, 4.4.15, 5.0.7 and 6.1.2.</failure>
        </testcase>
        <testcase classname="tar-4.4.13" name="[HIGH] CVE-2021-32804" time="">
            <failure message="nodejs-tar: Insufficient absolute path sanitization allowing arbitrary file creation and overwrite" type="description">The npm package &#34;tar&#34; (aka node-tar) before versions 6.1.1, 5.0.6, 4.4.14, and 3.3.2 has a arbitrary File Creation/Overwrite vulnerability due to insufficient absolute path sanitization. node-tar aims to prevent extraction of absolute file paths by turning absolute paths into relative paths when the `preservePaths` flag is not set to `true`. This is achieved by stripping the absolute path root from any absolute file paths contained in a tar file. For example `/home/user/.bashrc` would turn into `home/user/.bashrc`. This logic was insufficient when file paths contained repeated path roots such as `////home/user/.bashrc`. `node-tar` would only strip a single path root from such paths. When given an absolute file path with repeating path roots, the resulting path (e.g. `///home/user/.bashrc`) would still resolve to an absolute path, thus allowing arbitrary file creation and overwrite. This issue was addressed in releases 3.2.2, 4.4.14, 5.0.6 and 6.1.1. Users may work around this vulnerability without upgrading by creating a custom `onentry` method which sanitizes the `entry.path` or a `filter` method which removes entries with absolute paths. See referenced GitHub Advisory for details. Be aware of CVE-2021-32803 which fixes a similar bug in later versions of tar.</failure>
        </testcase>
        <testcase classname="tar-4.4.13" name="[HIGH] CVE-2021-37701" time="">
            <failure message="nodejs-tar: insufficient symlink protection due to directory cache poisoning using symbolic links allowing arbitrary file creation and overwrite" type="description">The npm package &#34;tar&#34; (aka node-tar) before versions 4.4.16, 5.0.8, and 6.1.7 has an arbitrary file creation/overwrite and arbitrary code execution vulnerability. node-tar aims to guarantee that any file whose location would be modified by a symbolic link is not extracted. This is, in part, achieved by ensuring that extracted directories are not symlinks. Additionally, in order to prevent unnecessary stat calls to determine whether a given path is a directory, paths are cached when directories are created. This logic was insufficient when extracting tar files that contained both a directory and a symlink with the same name as the directory, where the symlink and directory names in the archive entry used backslashes as a path separator on posix systems. The cache checking logic used both `\` and `/` characters as path separators, however `\` is a valid filename character on posix systems. By first creating a directory, and then replacing that directory with a symlink, it was thus possible to bypass node-tar symlink checks on directories, essentially allowing an untrusted tar file to symlink into an arbitrary location and subsequently extracting arbitrary files into that location, thus allowing arbitrary file creation and overwrite. Additionally, a similar confusion could arise on case-insensitive filesystems. If a tar archive contained a directory at `FOO`, followed by a symbolic link named `foo`, then on case-insensitive file systems, the creation of the symbolic link would remove the directory from the filesystem, but _not_ from the internal directory cache, as it would not be treated as a cache hit. A subsequent file entry within the `FOO` directory would then be placed in the target of the symbolic link, thinking that the directory had already been created. These issues were addressed in releases 4.4.16, 5.0.8 and 6.1.7. The v3 branch of node-tar has been deprecated and did not receive patches for these issues. If you are still using a v3 release we recommend you update to a more recent version of node-tar. If this is not possible, a workaround is available in the referenced GHSA-9r2w-394v-53qc.</failure>
        </testcase>
        <testcase classname="tar-4.4.13" name="[HIGH] CVE-2021-37712" time="">
            <failure message="nodejs-tar: insufficient symlink protection due to directory cache poisoning using symbolic links allowing arbitrary file creation and overwrite" type="description">The npm package &#34;tar&#34; (aka node-tar) before versions 4.4.18, 5.0.10, and 6.1.9 has an arbitrary file creation/overwrite and arbitrary code execution vulnerability. node-tar aims to guarantee that any file whose location would be modified by a symbolic link is not extracted. This is, in part, achieved by ensuring that extracted directories are not symlinks. Additionally, in order to prevent unnecessary stat calls to determine whether a given path is a directory, paths are cached when directories are created. This logic was insufficient when extracting tar files that contained both a directory and a symlink with names containing unicode values that normalized to the same value. Additionally, on Windows systems, long path portions would resolve to the same file system entities as their 8.3 &#34;short path&#34; counterparts. A specially crafted tar archive could thus include a directory with one form of the path, followed by a symbolic link with a different string that resolves to the same file system entity, followed by a file using the first form. By first creating a directory, and then replacing that directory with a symlink that had a different apparent name that resolved to the same entry in the filesystem, it was thus possible to bypass node-tar symlink checks on directories, essentially allowing an untrusted tar file to symlink into an arbitrary location and subsequently extracting arbitrary files into that location, thus allowing arbitrary file creation and overwrite. These issues were addressed in releases 4.4.18, 5.0.10 and 6.1.9. The v3 branch of node-tar has been deprecated and did not receive patches for these issues. If you are still using a v3 release we recommend you update to a more recent version of node-tar. If this is not possible, a workaround is available in the referenced GHSA-qq89-hq3f-393p.</failure>
        </testcase>
        <testcase classname="tar-4.4.13" name="[HIGH] CVE-2021-37713" time="">
            <failure message="Arbitrary File Creation/Overwrite on Windows via insufficient relative path sanitization" type="description">The npm package &#34;tar&#34; (aka node-tar) before versions 4.4.18, 5.0.10, and 6.1.9 has an arbitrary file creation/overwrite and arbitrary code execution vulnerability. node-tar aims to guarantee that any file whose location would be outside of the extraction target directory is not extracted. This is, in part, accomplished by sanitizing absolute paths of entries within the archive, skipping archive entries that contain `..` path portions, and resolving the sanitized paths against the extraction target directory. This logic was insufficient on Windows systems when extracting tar files that contained a path that was not an absolute path, but specified a drive letter different from the extraction target, such as `C:some\path`. If the drive letter does not match the extraction target, for example `D:\extraction\dir`, then the result of `path.resolve(extractionDirectory, entryPath)` would resolve against the current working directory on the `C:` drive, rather than the extraction target directory. Additionally, a `..` portion of the path could occur immediately after the drive letter, such as `C:../foo`, and was not properly sanitized by the logic that checked for `..` within the normalized and split portions of the path. This only affects users of `node-tar` on Windows systems. These issues were addressed in releases 4.4.18, 5.0.10 and 6.1.9. The v3 branch of node-tar has been deprecated and did not receive patches for these issues. If you are still using a v3 release we recommend you update to a more recent version of node-tar. There is no reasonable way to work around this issue without performing the same path normalization procedures that node-tar now does. Users are encouraged to upgrade to the latest patched versions of node-tar, rather than attempt to sanitize paths themselves.</failure>
        </testcase>
    </testsuite>
</testsuites>